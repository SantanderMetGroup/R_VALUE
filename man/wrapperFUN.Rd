% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrapperFUN.R
\name{wrapperFUN}
\alias{wrapperFUN}
\title{Wrapper function to launch the validation}
\usage{
wrapperFUN(metric = c("obs", "pred", "measure"), names = NULL,
  season = c("annual", "DJF", "MAM", "JJA", "SON"),
  member.aggregation = "none", index.fun = NULL, measure.fun = NULL,
  index.args = NULL, measure.args = NULL, o = o, p = p,
  processes = data.frame(), processNames = c(), na.prop = 1)
}
\arguments{
\item{metric}{Character vector.}

\item{names}{Character vector of the same length than \code{metric}. Names of the indices/measures to be applied}

\item{season}{Character vector defining the target season(s). Default to annual + 4 standard seasons.}

\item{member.aggregation}{Character vector of length one. What aggregation function should be applied to multipe realizations
before computing the indices?. Default to \code{"none"}, meaning that the indices are computed in a member-wise basis, and only
 after that the index values are aggregated to compute the measure. The only additional option currently used
  is \code{"mean"}, for cases when the realizations are averaged before computing the index. 
 Ignored for observations and deterministic predictions.}

\item{index.fun}{A character vector with the name of the R function that computes the index.}

\item{measure.fun}{A character vector with the name of the R function that computes the measure.}

\item{index.args}{A list with additional arguments passed to \code{index.fun}. It contains a key-value list for each additional argument.}

\item{measure.args}{Same as \code{index.args} but for the measure function.}

\item{o}{R object containing the observations as returned by \code{\link{loadValueStations}}.}

\item{p}{R object containing the predictions as returned by \code{\link{loadValuePredictions}}.}

\item{processes}{processes}

\item{processNames}{Labels identifying the processes}

\item{na.prop}{Maximum allowable proportion of missing data. Default to 0.9}
}
\value{
A 3D array with labelled dimensions station, season and metric
}
\description{
Launches the VALUE validation framework according to the arguments passed by the database.
}
\examples{
\dontrun{
# Load observations
obs.file <- file.path(find.package("R.VALUE"), "example_datasets", "VALUE_ECA_86_v2.zip")
o <- loadValueStations(obs.file, var = "tmin")
prdfile <- list.files(file.path(find.package("R.VALUE"), "example_datasets"),
                      pattern = "predictions_portal_exp1a_deterministic",
                      full.names = TRUE)
# Load predictions
p <- loadValuePredictions(o, predictions.file = prdfile)
# Create argument list for computing mean bias:
c1 = list()
c1$metric = c("obs", "pred", "measure")
c1$names = c("obsMean", "predMean","meanBias")
c1$season = c("annual", "DJF", "MAM", "JJA", "SON")
c1$member.aggregation = "none"
c1$index.fun = "index.mean.R"
c1$measure.fun = "measure.bias.R"
c1$index.args = NULL
c1$measure.args = NULL
c1$o = o
c1$p = p
c1$na.prop = .9

# Call validation wrapper
a <- do.call("wrapperFUN", c1)
str(a)
# Example stochastic
prdfile <- list.files(file.path(find.package("R.VALUE"), "example_datasets"),
                      pattern = "predictions_portal_exp1a_stochastic",
                      full.names = TRUE)
# Load predictions
p <- loadValuePredictions(o, predictions.file = prdfile)
c1$p = p

# Member-wise index calculation:
c1$member.aggregation = "none"
b <- do.call("wrapperFUN", c1)
str(b)
# Note the attribute 'member.aggregation'

# Member aggregation before computing the index (deterministic component):
c1$member.aggregation = "mean"
b1 <- do.call("wrapperFUN", c1)
str(b1)
}
}
\author{
J. Bedia, D. San Martin, M. Tuni
}

